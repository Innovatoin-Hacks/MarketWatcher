<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>Frameworks.TechnicalAnalyzer API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Frameworks.TechnicalAnalyzer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#Importing dependencies 
import pandas as pd
import numpy as np
import talib as ta
import math
import matplotlib.pyplot as plt
plt.rcParams[&#34;figure.figsize&#34;] = (20,10)

#Quandl dependency with API key
import quandl
quandl.ApiConfig.api_key = &#34;RB48Rib76iwBPxtzeVs2&#34;

class Tech_IndicatorEvaluator:
    
    #Init method for the class
    #This method extracts OHLCV details from the dataframe
    
    def __init__(self, dataframe):
        &#34;&#34;&#34;self.OHLCV = dataframe
        self.high = dataframe.iloc[:,1]
        self.low = dataframe.iloc[:,2]
        self.close = dataframe.iloc[:,4]
        self.volume = dataframe.iloc[:,5]
        self.data = dataframe.iloc[:,:7]
        &#34;&#34;&#34;
        self.high = dataframe.loc[:,&#39;High&#39;]
        self.low = dataframe.loc[:,&#39;Low&#39;]
        self.close = dataframe.loc[:,&#34;Close&#34;]
        if(&#39;Volume&#39; in dataframe.columns):
            self.volume = dataframe.loc[:,&#39;Volume&#39;]
            self.data = dataframe[[&#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;,&#39;Close&#39;,&#39;Volume&#39;]] 
        else:
            self.volume = dataframe.loc[:,&#39;Total Trade Quantity&#39;]
            self.data = dataframe[[&#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;,&#39;Close&#39;,&#39;Total Trade Quantity&#39;]]
        
    #Class method to return CorrMatrix, Indicator Values and Summary
    #Plot by default is False
    #If plot == True, A figure for the indicator shall be plotted with their dependent OHLC values.
    #X parameters must be of type String or None
    #Y parameters need to be type int/float or None
    
    def getIndicator(self,indicator, plot=False, xmin=None, xmax=None, ymin=None, ymax=None):
        
        if(xmin != None):
            if(type(xmin)!=str):
                raise ValueError(&#34;X parameters must be of type -&gt; str&#34;)
        
        if(xmax != None):
            if(type(xmax)!=str):
                raise ValueError(&#34;X parameters must be of type -&gt; str&#34;)
                
        if(ymin != None):
            if(not isinstance(ymin, (int, float))):
                raise ValueError(&#34;Y parameters must be of type -&gt; Int or Float&#34;)
                                 
        if(ymax != None):
            if(not isinstance(ymax, (int,float))):
                raise ValueError(&#34;Y parameters must be of type -&gt; Int or Float&#34;)
                
                
            &#34;&#34;&#34;
            Bollinger BandsÂ® are a technical analysis tool developed by John Bollinger.
            There are three lines that compose Bollinger Bands: A simple moving average (middle band) and an upper and lower band.
            The upper and lower bands are typically 2 standard deviations +/- from a 20-day simple moving average, but can be modified
        
            Many traders believe the closer the prices move to the upper band, the more overbought the market,
            and the closer the prices move to the lower band, the more oversold the market.
        
            &#34;&#34;&#34;
        if(indicator == &#39;BBANDS&#39;):
            BB = ta.BBANDS(self.close)  #talib function)
            BB_df = pd.DataFrame(list(BB)).transpose() #converting to Dataframe
            BB_df = BB_df.rename(columns={0:&#39;Upperband&#39;,1:&#34;Middleband&#34;,2:&#34;Lowerband&#34;}) #renaming columns
            BB_df = BB_df.join(self.data , how=&#39;inner&#39;) #inner join with the OHLCV dataframe(on common timestamps)
            BB_df = BB_df.dropna(axis=0) #drop NaNs
            BB_df_corr=BB_df.corr(method=&#39;pearson&#39;) #corr matrix
            
            if (plot == True):
                BB_plot = BB_df.loc[:,[&#39;Upperband&#39;,&#39;Middleband&#39;,&#39;Lowerband&#39;,&#39;Close&#39;]] #select dependent columns ---&gt; can be changed here 
                BB_plot.plot(ylim=(ymin,ymax),xlim=(xmin,xmax)) #plot figure
                return BB_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),BB_df,BB_df.describe() 
            else:
                return BB_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),BB_df,BB_df.describe()
            
            &#34;&#34;&#34;
            The Arron indicator is composed of two lines. 
            An up line which measures the number of periods since a High, 
            and a down line which measures the number of periods since a Low.
            
            When the Aroon Up is above the Aroon Down, it indicates bullish price behavior.
            When the Aroon Down is above the Aroon Up, it signals bearish price behavior.
            
            For example, when Aroon Up crosses above Aroon Down it may mean a new uptrend is starting.
            &#34;&#34;&#34;
        elif(indicator == &#39;AROON&#39;):
            aroondf = ta.AROON(self.high,self.low,timeperiod=20)
            aroondf= pd.DataFrame(list(aroondf)).transpose()
            aroondf = aroondf.rename(columns={0:&#34;AroonDown&#34;,1:&#34;AroonUp&#34;})
            aroondf = aroondf.join(self.data,how=&#39;inner&#39;)
            aroondf = aroondf.dropna(axis=0)
            aroon_corr = aroondf.corr()
            if(plot == True):
                aroon_plt= aroondf.iloc[:,[0,1,3,4]] #Selected Dependent columns ---&gt; can be changed here
                aroon_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return aroon_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),aroondf,aroondf.describe()
            else:
                return aroon_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),aroondf,aroondf.describe()
            
        elif(indicator == &#39;CCI&#39;):
            cci = list(ta.CCI(self.high, self.low, self.close)) #Talib function
            cci_df = self.data.copy() #creating a copy of OHLCV DataFramee
            cci_df[&#39;Real&#39;] = pd.Series(cci).values  #converting to a series and appending to the  prev Dataframe
            cci_df = cci_df.dropna(axis=0)
            cci_corr= cci_df.corr()
            #self.data=self.data.iloc[:,:6]  
            if(plot == True):
                cci_plt = cci_df.iloc[:,[1,2,6]]
                cci_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return cci_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cci_df,cci_df.describe()
            else:
                return cci_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cci_df,cci_df.describe()
        
        elif(indicator == &#39;ATR&#39;):
            atr = ta.ATR(self.high,self.low,self.close,timeperiod=14)
            atrdf= pd.DataFrame(atr)
            atrdf = atrdf.rename(columns={0:&#34;ATR_real&#34;})
            atrdf = atrdf.join(self.data,how=&#39;inner&#39;)
            atrdf = atrdf.dropna(axis=0)
            atr_corr = atrdf.corr()
            if(plot==True):
                atr_plt = atrdf.iloc[:,[0,2,3,5]]
                atr_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return atr_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),atrdf,atrdf.describe()
            else:
                return atr_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),atrdf,atrdf.describe()
        
        elif(indicator == &#39;CHAIKINAD&#39;):
            chaikinad = ta.AD(self.high, self.low, self.close, self.volume)
            chaikinad_df = pd.DataFrame(chaikinad)
            chaikinad_df = chaikinad_df.rename(columns={0:&#34;ChaikinAD&#34;})
            chaikinad_df = chaikinad_df.join(self.data,how=&#39;inner&#39;)
            chaikinad_df = chaikinad_df.dropna(axis=0)
            chaikinad_corr = chaikinad_df.corr()
            if(plot==True):
                chaikinad_plt = chaikinad_df.iloc[:,[0,2,3,5]]
                chaikinad_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return chaikinad_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikinad_df,chaikinad_df.describe()
            else:
                return chaikinad_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikinad_df,chaikinad_df.describe()
            
        elif(indicator == &#39;CHAIKINVOLATILITY&#39;):
            chaikin_os = ta.ADOSC(self.high,self.low,self.close,self.volume)
            chaikin_os_df = pd.DataFrame(chaikin_os)
            chaikin_os_df = chaikin_os_df.rename(columns={0:&#34;ChaikinOSC&#34;})
            chaikin_os_df = chaikin_os_df.join(self.data,how=&#39;inner&#39;)
            chaikin_os_df = chaikin_os_df.dropna(axis=0)
            chaikin_os_corr= chaikin_os_df.corr()
            if(plot==True):
                chaikin_os_plt = chaikin_os_df.iloc[:,[0,2,3,5]]
                chaikin_os_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return chaikin_os_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikin_os_df,chaikin_os_df.describe()
            else:
                return chaikin_os_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikin_os_df,chaikin_os_df.describe()
            
        elif(indicator == &#39;CMO&#39;):
            cmo = ta.CMO(self.close, timeperiod=14)
            cmo_df = pd.DataFrame(cmo)
            cmo_df = cmo_df.rename(columns={0:&#34;CMO&#34;})
            cmo_df = cmo_df.join(self.data,how=&#39;inner&#39;)
            cmo_df = cmo_df.dropna(axis=0)
            cmo_corr = cmo_df.corr()
            if(plot==True):
                cmo_plt = cmo_df.iloc[:,[0,5]]
                cmo_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return cmo_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmo_df,cmo_df.describe()
            else:
                return cmo_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmo_df,cmo_df.describe()
        
        elif(indicator == &#39;MACD&#39;):
            macd = ta.MACD(self.close, fastperiod=6, slowperiod=13, signalperiod=5)
            macd_df = pd.DataFrame(macd).transpose()
            macd_df = macd_df.rename(columns={0:&#34;macd&#34;,1:&#34;MACDSignal&#34;,2:&#34;MACDHist&#34;})
            macd_df = macd_df.join(self.data,how=&#39;inner&#39;)
            macd_df = macd_df.dropna(axis=0)
            macd_df_corr = macd_df.corr()
            if(plot == True):
                macd_plt = macd_df.iloc[:,[0,1,7]]
                macd_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return macd_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),macd_df,macd_df.describe()
            else:
                return macd_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),macd_df,macd_df.describe()
        
        elif(indicator == &#39;ROC&#39;):
            roc = ta.ROC(self.close, timeperiod=14)
            roc_df = pd.DataFrame(roc)
            roc_df = roc_df.rename(columns={0:&#34;ROC_value&#34;})
            roc_df = roc_df.join(self.data,how=&#39;inner&#39;)
            roc_df_corr= roc_df.corr()
            if(plot == True):
                roc_df_plt = roc_df.iloc[:,[0,5]]
                roc_df_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return roc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),roc_df,roc_df.describe()
            else:
                return roc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),roc_df,roc_df.describe()
        
        elif(indicator == &#39;MOMENTUM&#39;):
            mom = ta.MOM(self.close , timeperiod=14)
            mom_df = pd.DataFrame(mom)
            mom_df = mom_df.rename(columns={0:&#39;Momentum&#39;})
            mom_df = mom_df.join(self.data,how=&#39;inner&#39;)
            mom_df_corr = mom_df.corr()
            if(plot==True):
                mom_plt=mom_df.iloc[:,[0,5]]
                mom_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return mom_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mom_df,mom_df.describe()
            else:
                return mom_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mom_df,mom_df.describe()
        
        elif(indicator == &#39;RSI&#39;):
            rsi = ta.RSI(self.close, timeperiod=14)
            rsi_df = pd.DataFrame(rsi)
            rsi_df = rsi_df.rename(columns={0:&#34;RSI&#34;})
            rsi_df = rsi_df.join(self.data,how=&#34;inner&#34;)
            rsi_df = rsi_df.dropna(axis=0)
            rsi_df_corr = rsi_df.corr()
            if(plot == True):
                rsi_plt = rsi_df.iloc[:,[0,5]]
                rsi_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return rsi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),rsi_df,rsi_df.describe()
            else:
                return rsi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),rsi_df,rsi_df.describe()
            
        elif(indicator == &#39;MFI&#39;):
            mfi = ta.MFI(self.high, self.low, self.close, self.volume, timeperiod=14)
            mfi_df = pd.DataFrame(mfi)
            mfi_df = mfi_df.rename(columns={0:&#34;MFI&#34;})
            mfi_df = mfi_df.join(self.data,how=&#39;inner&#39;)
            mfi_df = mfi_df.dropna(axis=0)
            mfi_df_corr= mfi_df.corr()
            if(plot==True):
                mfi_plt = mfi_df.iloc[:,[0,2,3,5,6]]
                mfi_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return mfi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mfi_df,mfi_df.describe()
            else:
                return mfi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mfi_df,mfi_df.describe()
        
        elif(indicator == &#39;OBV&#39;):
            obv = ta.OBV(self.close, self.volume)
            obv_df = pd.DataFrame(obv)
            obv_df = obv_df.rename(columns={0:&#39;OBV&#39;})
            obv_df = obv_df.join(self.data,how=&#39;inner&#39;)
            obv_df_corr = obv_df.corr()
            if(plot == True):
                obv_plt = obv_df.iloc[:,[0,5]]
                obv_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return obv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),obv_df,obv_df.describe()
            else:
                return obv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),obv_df,obv_df.describe()
            
        elif(indicator == &#39;SAR&#39;):
            sar = ta.SAR(self.high, self.low, acceleration=1, maximum=1)
            sar_df = pd.DataFrame(sar)
            sar_df = sar_df.rename(columns={0:&#39;SAR&#39;})
            sar_df = sar_df.join(self.data,how=&#39;inner&#39;)
            sar_df = sar_df.dropna(axis=0)
            sar_df_corr = sar_df.corr()
            if(plot == True):
                sar_plt = sar_df.iloc[:,[0,2,3]]
                sar_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return sar_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),sar_df,sar_df.describe()
            else:
                return sar_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),sar_df,sar_df.describe()
            
        elif(indicator == &#39;STOCHASTIC&#39;):
            stoch = ta.STOCH(self.high, self.low, self.close, fastk_period=14, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0)
            stoch_df = pd.DataFrame(list(stoch)).transpose()
            stoch_df = stoch_df.rename(columns={0:&#34;SlowK&#34;,1:&#34;SlowD&#34;})
            stoch_df = stoch_df.join(self.data,how=&#39;inner&#39;)
            stoch_df = stoch_df.dropna(axis=0)
            stoch_df_corr = stoch_df.corr()
            if(plot == True):
                stoch_plt = stoch_df.iloc[:,[0,1,3,4,6]]
                stoch_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return stoch_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),stoch_df,stoch_df.describe()
            else:
                return stoch_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),stoch_df,stoch_df.describe()
            
        elif(indicator == &#39;TRIX&#39;):
            trix = ta.TRIX(self.close, timeperiod=20)
            trix_df = pd.DataFrame(trix)
            trix_df = trix_df.rename(columns={0:&#39;Trix&#39;})
            trix_df= trix_df.join(self.data, how=&#39;inner&#39;)
            trix_df = trix_df.dropna(axis=0)
            trix_df_corr = trix_df.corr()
            if(plot==True):
                trix_plt = trix_df.iloc[:,[0,5]]
                trix_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return trix_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),trix_df,trix_df.describe()
            else:
                return trix_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),trix_df,trix_df.describe()
            
        elif(indicator == &#39;ultimateOscillator&#39;):
            ultiosc = ta.ULTOSC(self.high, self.low, self.close, timeperiod1=7, timeperiod2=14, timeperiod3=28)
            ultiosc_df = pd.DataFrame(ultiosc)
            ultiosc_df = ultiosc_df.rename(columns={0:&#34;ULTI_OSC&#34;})
            ultiosc_df = ultiosc_df.join(self.data,how=&#39;inner&#39;)
            ultiosc_df = ultiosc_df.dropna(axis=0)
            ultiosc_df_corr = ultiosc_df.corr()
            if(plot == True):
                ultiosc_plt = ultiosc_df.iloc[:,[0,2,3,5]]
                ultiosc_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return ultiosc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),ultiosc_df,ultiosc_df.describe()
            else:
                return ultiosc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),ultiosc_df,ultiosc_df.describe()
        
        elif(indicator == &#39;CLV&#39;):
            clvlist = [] #creating an empty list 
            for i in range(0, self.data.shape[0]):
                #CLV = ((Close - Low) - (High - Close))/(High - Low)
                clv = ((self.data.iloc[i,3] - self.data.iloc[i,2]) - 
                       (self.data.iloc[i,1] - self.data.iloc[i,3]))/(self.data.iloc[i,1] - self.data.iloc[i,2])
                clvlist.append(clv) #appending values to list
            clv_df = pd.DataFrame() #creating an empty Dataframe
            clv_df = self.data.copy() #creating a copy of OHLCV Dataframe
            clv_df[&#39;CLV&#39;] = clvlist #appending a column of values from clvlist
            clv_df_corr = clv_df.corr() #corr matrix
            
            if(plot==True):
                clv_plt = clv_df.iloc[:,[1,2,4,6]]
                clv_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return clv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),clv_df,clv_df.describe()
            else:
                return clv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),clv_df,clv_df.describe()
        
        elif(indicator == &#39;CMF&#39;):
            temp =[] #empty list
            for i in range(0,self.data.shape[0]):
                
                #MoneyFlowMultiplier = ((Close - Low) - (High - Close))/(High - Low)
                mfm = ((self.data.iloc[i,3] - self.data.iloc[i,2]) - (self.data.iloc[i,1] - self.data.iloc[i,3]))/(self.data.iloc[i,1] - self.data.iloc[i,2])
                #MoneyFlowMultipler x Volume of that period = MoneyFlow Volume
                cmf = mfm*self.data.iloc[i,4]
                temp.append(cmf)
                
            cmf_df = pd.DataFrame() #Create an empty dataframe
            cmf_df[&#39;MFVolume&#39;] = temp #append list in Dataframe
            cmf_df[&#39;Volume&#39;] = list(self.volume) #Add Volume data in dataframe
            cmf_df = cmf_df.rolling(20).sum() #Rolling sum for timeperiod = 20 ----&gt; can be changed
            cmf_df[&#39;Ratio&#39;] = cmf_df[&#39;MFVolume&#39;]/cmf_df[&#39;Volume&#39;] #Taking raio
            cmflist = list(cmf_df.iloc[:,2]) #creating a list of the ratios obtained
            cmf_df = pd.DataFrame() #appending it to the empty DataFrame
            cmf_df = self.data.copy()
            cmf_df[&#39;CMF&#39;] = cmflist
            cmf_df = cmf_df.dropna(axis=0) #Dropping NaN
            cmf_df_corr = cmf_df.corr() #Corr Matrix
            if(plot==True):
                cmf_plt = cmf_df.iloc[:,[1,2,4,5,6]]
                cmf_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return cmf_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmf_df,cmf_df.describe()
            else:
                return cmf_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmf_df,cmf_df.describe()
            
        elif(indicator == &#39;Donchain&#39;):
            temp =[]
            highest = pd.DataFrame(self.data.iloc[:,1].rolling(20).max()) #Highest 20 day high
            lowest = pd.DataFrame(self.data.iloc[:,2].rolling(20).min()) #Lowest 20 day Low
            combined = highest.join(lowest,how=&#39;inner&#39;) #comibining on inner join
            for i in range(0,combined.shape[0]):
                if(math.isnan(combined.iloc[i,1]) == True or math.isnan(combined.iloc[i,0] == True)):
                    temp.append(None)
                else:
                    temp.append((combined.iloc[i,0] + combined.iloc[i,1])/2) #The middle = (Highest+Lowest)/2
            combined[&#39;Mid&#39;] = temp
            combined = combined.rename(columns={&#39;High&#39;:&#34;Upper&#34;,&#34;Low&#34;:&#39;Lower&#39;,&#34;Mid&#34;:&#34;Middle&#34;}) #Renaming Columns
            donchain_df = combined.join(self.data, how=&#39;inner&#39;) #joining with OHLCV data
            donchain_df.dropna(axis=0) #Dropping NaNs
            donchain_df_corr = donchain_df.corr()
            if(plot == True):
                donchain_plt = donchain_df.iloc[:,[0,1,2,4,5,7]]
                donchain_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return donchain_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),donchain_df,donchain_df.describe()
            else:
                return donchain_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),donchain_df,donchain_df.describe()
            
        elif(indicator == &#39;DPO&#39;):
            time = 20
            dpo = ta.SMA(self.close, timeperiod=time) #Calculate Simple Moving Average
            dpo_df = pd.DataFrame(dpo)
            dpo_df[&#39;DPO&#39;] = np.nan #Create a column filled with NaNs
            
            #Start from i = timeperiod 
            for i in range(time-1,dpo_df.shape[0]):
                #(Price of (N/2 + 1) periods ago) - (N Period SMA) = DPO
                dpo_df.iloc[i,1] = self.data.iloc[(i//2+1),3] - dpo_df.iloc[i,0]
                
            dpo_df = dpo_df.join(self.data,how=&#39;inner&#39;) #inner join
            dpo_df = dpo_df.dropna(axis=0) #dropping nans
            dpo_df = dpo_df.iloc[:,1:]
            dpo_df_corr = dpo_df.corr() #corr matrix
            if(plot == True):
                dpo_plt =dpo_df.iloc[:,[0,5]]
                dpo_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return dpo_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),dpo_df,dpo_df.describe()
            else:
                return dpo_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),dpo_df,dpo_df.describe()
        
        elif(indicator == &#39;ADX&#39;):
            adx = ta.ADX(self.high, self.low, self.close, timeperiod=14)
            adx_df = pd.DataFrame(adx)
            adx_df = adx_df.rename(columns={0:&#39;ADX&#39;})
            adx_df = adx_df.join(self.data,how=&#39;inner&#39;)
            adx_df = adx_df.dropna(axis=0)
            adx_df_corr = adx_df.corr()
            if(plot==True):
                adx_plt = adx_df.iloc[:,[0,2,3,5]]
                adx_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return adx_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),adx_df,adx_df.describe()
            else:
                return adx_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),adx_df,adx_df.describe()
        
        else:
            raise ValueError(&#34;Invalid Indicator Symbol&#34;)
            </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Frameworks.TechnicalAnalyzer.Tech_IndicatorEvaluator"><code class="flex name class">
<span>class <span class="ident">Tech_IndicatorEvaluator</span></span>
<span>(</span><span>dataframe)</span>
</code></dt>
<dd>
<section class="desc"><p>self.OHLCV = dataframe
self.high = dataframe.iloc[:,1]
self.low = dataframe.iloc[:,2]
self.close = dataframe.iloc[:,4]
self.volume = dataframe.iloc[:,5]
self.data = dataframe.iloc[:,:7]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tech_IndicatorEvaluator:
    
    #Init method for the class
    #This method extracts OHLCV details from the dataframe
    
    def __init__(self, dataframe):
        &#34;&#34;&#34;self.OHLCV = dataframe
        self.high = dataframe.iloc[:,1]
        self.low = dataframe.iloc[:,2]
        self.close = dataframe.iloc[:,4]
        self.volume = dataframe.iloc[:,5]
        self.data = dataframe.iloc[:,:7]
        &#34;&#34;&#34;
        self.high = dataframe.loc[:,&#39;High&#39;]
        self.low = dataframe.loc[:,&#39;Low&#39;]
        self.close = dataframe.loc[:,&#34;Close&#34;]
        if(&#39;Volume&#39; in dataframe.columns):
            self.volume = dataframe.loc[:,&#39;Volume&#39;]
            self.data = dataframe[[&#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;,&#39;Close&#39;,&#39;Volume&#39;]] 
        else:
            self.volume = dataframe.loc[:,&#39;Total Trade Quantity&#39;]
            self.data = dataframe[[&#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;,&#39;Close&#39;,&#39;Total Trade Quantity&#39;]]
        
    #Class method to return CorrMatrix, Indicator Values and Summary
    #Plot by default is False
    #If plot == True, A figure for the indicator shall be plotted with their dependent OHLC values.
    #X parameters must be of type String or None
    #Y parameters need to be type int/float or None
    
    def getIndicator(self,indicator, plot=False, xmin=None, xmax=None, ymin=None, ymax=None):
        
        if(xmin != None):
            if(type(xmin)!=str):
                raise ValueError(&#34;X parameters must be of type -&gt; str&#34;)
        
        if(xmax != None):
            if(type(xmax)!=str):
                raise ValueError(&#34;X parameters must be of type -&gt; str&#34;)
                
        if(ymin != None):
            if(not isinstance(ymin, (int, float))):
                raise ValueError(&#34;Y parameters must be of type -&gt; Int or Float&#34;)
                                 
        if(ymax != None):
            if(not isinstance(ymax, (int,float))):
                raise ValueError(&#34;Y parameters must be of type -&gt; Int or Float&#34;)
                
                
            &#34;&#34;&#34;
            Bollinger BandsÂ® are a technical analysis tool developed by John Bollinger.
            There are three lines that compose Bollinger Bands: A simple moving average (middle band) and an upper and lower band.
            The upper and lower bands are typically 2 standard deviations +/- from a 20-day simple moving average, but can be modified
        
            Many traders believe the closer the prices move to the upper band, the more overbought the market,
            and the closer the prices move to the lower band, the more oversold the market.
        
            &#34;&#34;&#34;
        if(indicator == &#39;BBANDS&#39;):
            BB = ta.BBANDS(self.close)  #talib function)
            BB_df = pd.DataFrame(list(BB)).transpose() #converting to Dataframe
            BB_df = BB_df.rename(columns={0:&#39;Upperband&#39;,1:&#34;Middleband&#34;,2:&#34;Lowerband&#34;}) #renaming columns
            BB_df = BB_df.join(self.data , how=&#39;inner&#39;) #inner join with the OHLCV dataframe(on common timestamps)
            BB_df = BB_df.dropna(axis=0) #drop NaNs
            BB_df_corr=BB_df.corr(method=&#39;pearson&#39;) #corr matrix
            
            if (plot == True):
                BB_plot = BB_df.loc[:,[&#39;Upperband&#39;,&#39;Middleband&#39;,&#39;Lowerband&#39;,&#39;Close&#39;]] #select dependent columns ---&gt; can be changed here 
                BB_plot.plot(ylim=(ymin,ymax),xlim=(xmin,xmax)) #plot figure
                return BB_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),BB_df,BB_df.describe() 
            else:
                return BB_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),BB_df,BB_df.describe()
            
            &#34;&#34;&#34;
            The Arron indicator is composed of two lines. 
            An up line which measures the number of periods since a High, 
            and a down line which measures the number of periods since a Low.
            
            When the Aroon Up is above the Aroon Down, it indicates bullish price behavior.
            When the Aroon Down is above the Aroon Up, it signals bearish price behavior.
            
            For example, when Aroon Up crosses above Aroon Down it may mean a new uptrend is starting.
            &#34;&#34;&#34;
        elif(indicator == &#39;AROON&#39;):
            aroondf = ta.AROON(self.high,self.low,timeperiod=20)
            aroondf= pd.DataFrame(list(aroondf)).transpose()
            aroondf = aroondf.rename(columns={0:&#34;AroonDown&#34;,1:&#34;AroonUp&#34;})
            aroondf = aroondf.join(self.data,how=&#39;inner&#39;)
            aroondf = aroondf.dropna(axis=0)
            aroon_corr = aroondf.corr()
            if(plot == True):
                aroon_plt= aroondf.iloc[:,[0,1,3,4]] #Selected Dependent columns ---&gt; can be changed here
                aroon_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return aroon_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),aroondf,aroondf.describe()
            else:
                return aroon_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),aroondf,aroondf.describe()
            
        elif(indicator == &#39;CCI&#39;):
            cci = list(ta.CCI(self.high, self.low, self.close)) #Talib function
            cci_df = self.data.copy() #creating a copy of OHLCV DataFramee
            cci_df[&#39;Real&#39;] = pd.Series(cci).values  #converting to a series and appending to the  prev Dataframe
            cci_df = cci_df.dropna(axis=0)
            cci_corr= cci_df.corr()
            #self.data=self.data.iloc[:,:6]  
            if(plot == True):
                cci_plt = cci_df.iloc[:,[1,2,6]]
                cci_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return cci_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cci_df,cci_df.describe()
            else:
                return cci_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cci_df,cci_df.describe()
        
        elif(indicator == &#39;ATR&#39;):
            atr = ta.ATR(self.high,self.low,self.close,timeperiod=14)
            atrdf= pd.DataFrame(atr)
            atrdf = atrdf.rename(columns={0:&#34;ATR_real&#34;})
            atrdf = atrdf.join(self.data,how=&#39;inner&#39;)
            atrdf = atrdf.dropna(axis=0)
            atr_corr = atrdf.corr()
            if(plot==True):
                atr_plt = atrdf.iloc[:,[0,2,3,5]]
                atr_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return atr_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),atrdf,atrdf.describe()
            else:
                return atr_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),atrdf,atrdf.describe()
        
        elif(indicator == &#39;CHAIKINAD&#39;):
            chaikinad = ta.AD(self.high, self.low, self.close, self.volume)
            chaikinad_df = pd.DataFrame(chaikinad)
            chaikinad_df = chaikinad_df.rename(columns={0:&#34;ChaikinAD&#34;})
            chaikinad_df = chaikinad_df.join(self.data,how=&#39;inner&#39;)
            chaikinad_df = chaikinad_df.dropna(axis=0)
            chaikinad_corr = chaikinad_df.corr()
            if(plot==True):
                chaikinad_plt = chaikinad_df.iloc[:,[0,2,3,5]]
                chaikinad_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return chaikinad_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikinad_df,chaikinad_df.describe()
            else:
                return chaikinad_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikinad_df,chaikinad_df.describe()
            
        elif(indicator == &#39;CHAIKINVOLATILITY&#39;):
            chaikin_os = ta.ADOSC(self.high,self.low,self.close,self.volume)
            chaikin_os_df = pd.DataFrame(chaikin_os)
            chaikin_os_df = chaikin_os_df.rename(columns={0:&#34;ChaikinOSC&#34;})
            chaikin_os_df = chaikin_os_df.join(self.data,how=&#39;inner&#39;)
            chaikin_os_df = chaikin_os_df.dropna(axis=0)
            chaikin_os_corr= chaikin_os_df.corr()
            if(plot==True):
                chaikin_os_plt = chaikin_os_df.iloc[:,[0,2,3,5]]
                chaikin_os_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return chaikin_os_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikin_os_df,chaikin_os_df.describe()
            else:
                return chaikin_os_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikin_os_df,chaikin_os_df.describe()
            
        elif(indicator == &#39;CMO&#39;):
            cmo = ta.CMO(self.close, timeperiod=14)
            cmo_df = pd.DataFrame(cmo)
            cmo_df = cmo_df.rename(columns={0:&#34;CMO&#34;})
            cmo_df = cmo_df.join(self.data,how=&#39;inner&#39;)
            cmo_df = cmo_df.dropna(axis=0)
            cmo_corr = cmo_df.corr()
            if(plot==True):
                cmo_plt = cmo_df.iloc[:,[0,5]]
                cmo_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return cmo_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmo_df,cmo_df.describe()
            else:
                return cmo_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmo_df,cmo_df.describe()
        
        elif(indicator == &#39;MACD&#39;):
            macd = ta.MACD(self.close, fastperiod=6, slowperiod=13, signalperiod=5)
            macd_df = pd.DataFrame(macd).transpose()
            macd_df = macd_df.rename(columns={0:&#34;macd&#34;,1:&#34;MACDSignal&#34;,2:&#34;MACDHist&#34;})
            macd_df = macd_df.join(self.data,how=&#39;inner&#39;)
            macd_df = macd_df.dropna(axis=0)
            macd_df_corr = macd_df.corr()
            if(plot == True):
                macd_plt = macd_df.iloc[:,[0,1,7]]
                macd_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return macd_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),macd_df,macd_df.describe()
            else:
                return macd_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),macd_df,macd_df.describe()
        
        elif(indicator == &#39;ROC&#39;):
            roc = ta.ROC(self.close, timeperiod=14)
            roc_df = pd.DataFrame(roc)
            roc_df = roc_df.rename(columns={0:&#34;ROC_value&#34;})
            roc_df = roc_df.join(self.data,how=&#39;inner&#39;)
            roc_df_corr= roc_df.corr()
            if(plot == True):
                roc_df_plt = roc_df.iloc[:,[0,5]]
                roc_df_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return roc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),roc_df,roc_df.describe()
            else:
                return roc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),roc_df,roc_df.describe()
        
        elif(indicator == &#39;MOMENTUM&#39;):
            mom = ta.MOM(self.close , timeperiod=14)
            mom_df = pd.DataFrame(mom)
            mom_df = mom_df.rename(columns={0:&#39;Momentum&#39;})
            mom_df = mom_df.join(self.data,how=&#39;inner&#39;)
            mom_df_corr = mom_df.corr()
            if(plot==True):
                mom_plt=mom_df.iloc[:,[0,5]]
                mom_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return mom_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mom_df,mom_df.describe()
            else:
                return mom_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mom_df,mom_df.describe()
        
        elif(indicator == &#39;RSI&#39;):
            rsi = ta.RSI(self.close, timeperiod=14)
            rsi_df = pd.DataFrame(rsi)
            rsi_df = rsi_df.rename(columns={0:&#34;RSI&#34;})
            rsi_df = rsi_df.join(self.data,how=&#34;inner&#34;)
            rsi_df = rsi_df.dropna(axis=0)
            rsi_df_corr = rsi_df.corr()
            if(plot == True):
                rsi_plt = rsi_df.iloc[:,[0,5]]
                rsi_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return rsi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),rsi_df,rsi_df.describe()
            else:
                return rsi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),rsi_df,rsi_df.describe()
            
        elif(indicator == &#39;MFI&#39;):
            mfi = ta.MFI(self.high, self.low, self.close, self.volume, timeperiod=14)
            mfi_df = pd.DataFrame(mfi)
            mfi_df = mfi_df.rename(columns={0:&#34;MFI&#34;})
            mfi_df = mfi_df.join(self.data,how=&#39;inner&#39;)
            mfi_df = mfi_df.dropna(axis=0)
            mfi_df_corr= mfi_df.corr()
            if(plot==True):
                mfi_plt = mfi_df.iloc[:,[0,2,3,5,6]]
                mfi_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return mfi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mfi_df,mfi_df.describe()
            else:
                return mfi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mfi_df,mfi_df.describe()
        
        elif(indicator == &#39;OBV&#39;):
            obv = ta.OBV(self.close, self.volume)
            obv_df = pd.DataFrame(obv)
            obv_df = obv_df.rename(columns={0:&#39;OBV&#39;})
            obv_df = obv_df.join(self.data,how=&#39;inner&#39;)
            obv_df_corr = obv_df.corr()
            if(plot == True):
                obv_plt = obv_df.iloc[:,[0,5]]
                obv_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return obv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),obv_df,obv_df.describe()
            else:
                return obv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),obv_df,obv_df.describe()
            
        elif(indicator == &#39;SAR&#39;):
            sar = ta.SAR(self.high, self.low, acceleration=1, maximum=1)
            sar_df = pd.DataFrame(sar)
            sar_df = sar_df.rename(columns={0:&#39;SAR&#39;})
            sar_df = sar_df.join(self.data,how=&#39;inner&#39;)
            sar_df = sar_df.dropna(axis=0)
            sar_df_corr = sar_df.corr()
            if(plot == True):
                sar_plt = sar_df.iloc[:,[0,2,3]]
                sar_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return sar_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),sar_df,sar_df.describe()
            else:
                return sar_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),sar_df,sar_df.describe()
            
        elif(indicator == &#39;STOCHASTIC&#39;):
            stoch = ta.STOCH(self.high, self.low, self.close, fastk_period=14, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0)
            stoch_df = pd.DataFrame(list(stoch)).transpose()
            stoch_df = stoch_df.rename(columns={0:&#34;SlowK&#34;,1:&#34;SlowD&#34;})
            stoch_df = stoch_df.join(self.data,how=&#39;inner&#39;)
            stoch_df = stoch_df.dropna(axis=0)
            stoch_df_corr = stoch_df.corr()
            if(plot == True):
                stoch_plt = stoch_df.iloc[:,[0,1,3,4,6]]
                stoch_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return stoch_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),stoch_df,stoch_df.describe()
            else:
                return stoch_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),stoch_df,stoch_df.describe()
            
        elif(indicator == &#39;TRIX&#39;):
            trix = ta.TRIX(self.close, timeperiod=20)
            trix_df = pd.DataFrame(trix)
            trix_df = trix_df.rename(columns={0:&#39;Trix&#39;})
            trix_df= trix_df.join(self.data, how=&#39;inner&#39;)
            trix_df = trix_df.dropna(axis=0)
            trix_df_corr = trix_df.corr()
            if(plot==True):
                trix_plt = trix_df.iloc[:,[0,5]]
                trix_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return trix_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),trix_df,trix_df.describe()
            else:
                return trix_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),trix_df,trix_df.describe()
            
        elif(indicator == &#39;ultimateOscillator&#39;):
            ultiosc = ta.ULTOSC(self.high, self.low, self.close, timeperiod1=7, timeperiod2=14, timeperiod3=28)
            ultiosc_df = pd.DataFrame(ultiosc)
            ultiosc_df = ultiosc_df.rename(columns={0:&#34;ULTI_OSC&#34;})
            ultiosc_df = ultiosc_df.join(self.data,how=&#39;inner&#39;)
            ultiosc_df = ultiosc_df.dropna(axis=0)
            ultiosc_df_corr = ultiosc_df.corr()
            if(plot == True):
                ultiosc_plt = ultiosc_df.iloc[:,[0,2,3,5]]
                ultiosc_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return ultiosc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),ultiosc_df,ultiosc_df.describe()
            else:
                return ultiosc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),ultiosc_df,ultiosc_df.describe()
        
        elif(indicator == &#39;CLV&#39;):
            clvlist = [] #creating an empty list 
            for i in range(0, self.data.shape[0]):
                #CLV = ((Close - Low) - (High - Close))/(High - Low)
                clv = ((self.data.iloc[i,3] - self.data.iloc[i,2]) - 
                       (self.data.iloc[i,1] - self.data.iloc[i,3]))/(self.data.iloc[i,1] - self.data.iloc[i,2])
                clvlist.append(clv) #appending values to list
            clv_df = pd.DataFrame() #creating an empty Dataframe
            clv_df = self.data.copy() #creating a copy of OHLCV Dataframe
            clv_df[&#39;CLV&#39;] = clvlist #appending a column of values from clvlist
            clv_df_corr = clv_df.corr() #corr matrix
            
            if(plot==True):
                clv_plt = clv_df.iloc[:,[1,2,4,6]]
                clv_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return clv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),clv_df,clv_df.describe()
            else:
                return clv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),clv_df,clv_df.describe()
        
        elif(indicator == &#39;CMF&#39;):
            temp =[] #empty list
            for i in range(0,self.data.shape[0]):
                
                #MoneyFlowMultiplier = ((Close - Low) - (High - Close))/(High - Low)
                mfm = ((self.data.iloc[i,3] - self.data.iloc[i,2]) - (self.data.iloc[i,1] - self.data.iloc[i,3]))/(self.data.iloc[i,1] - self.data.iloc[i,2])
                #MoneyFlowMultipler x Volume of that period = MoneyFlow Volume
                cmf = mfm*self.data.iloc[i,4]
                temp.append(cmf)
                
            cmf_df = pd.DataFrame() #Create an empty dataframe
            cmf_df[&#39;MFVolume&#39;] = temp #append list in Dataframe
            cmf_df[&#39;Volume&#39;] = list(self.volume) #Add Volume data in dataframe
            cmf_df = cmf_df.rolling(20).sum() #Rolling sum for timeperiod = 20 ----&gt; can be changed
            cmf_df[&#39;Ratio&#39;] = cmf_df[&#39;MFVolume&#39;]/cmf_df[&#39;Volume&#39;] #Taking raio
            cmflist = list(cmf_df.iloc[:,2]) #creating a list of the ratios obtained
            cmf_df = pd.DataFrame() #appending it to the empty DataFrame
            cmf_df = self.data.copy()
            cmf_df[&#39;CMF&#39;] = cmflist
            cmf_df = cmf_df.dropna(axis=0) #Dropping NaN
            cmf_df_corr = cmf_df.corr() #Corr Matrix
            if(plot==True):
                cmf_plt = cmf_df.iloc[:,[1,2,4,5,6]]
                cmf_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return cmf_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmf_df,cmf_df.describe()
            else:
                return cmf_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmf_df,cmf_df.describe()
            
        elif(indicator == &#39;Donchain&#39;):
            temp =[]
            highest = pd.DataFrame(self.data.iloc[:,1].rolling(20).max()) #Highest 20 day high
            lowest = pd.DataFrame(self.data.iloc[:,2].rolling(20).min()) #Lowest 20 day Low
            combined = highest.join(lowest,how=&#39;inner&#39;) #comibining on inner join
            for i in range(0,combined.shape[0]):
                if(math.isnan(combined.iloc[i,1]) == True or math.isnan(combined.iloc[i,0] == True)):
                    temp.append(None)
                else:
                    temp.append((combined.iloc[i,0] + combined.iloc[i,1])/2) #The middle = (Highest+Lowest)/2
            combined[&#39;Mid&#39;] = temp
            combined = combined.rename(columns={&#39;High&#39;:&#34;Upper&#34;,&#34;Low&#34;:&#39;Lower&#39;,&#34;Mid&#34;:&#34;Middle&#34;}) #Renaming Columns
            donchain_df = combined.join(self.data, how=&#39;inner&#39;) #joining with OHLCV data
            donchain_df.dropna(axis=0) #Dropping NaNs
            donchain_df_corr = donchain_df.corr()
            if(plot == True):
                donchain_plt = donchain_df.iloc[:,[0,1,2,4,5,7]]
                donchain_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return donchain_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),donchain_df,donchain_df.describe()
            else:
                return donchain_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),donchain_df,donchain_df.describe()
            
        elif(indicator == &#39;DPO&#39;):
            time = 20
            dpo = ta.SMA(self.close, timeperiod=time) #Calculate Simple Moving Average
            dpo_df = pd.DataFrame(dpo)
            dpo_df[&#39;DPO&#39;] = np.nan #Create a column filled with NaNs
            
            #Start from i = timeperiod 
            for i in range(time-1,dpo_df.shape[0]):
                #(Price of (N/2 + 1) periods ago) - (N Period SMA) = DPO
                dpo_df.iloc[i,1] = self.data.iloc[(i//2+1),3] - dpo_df.iloc[i,0]
                
            dpo_df = dpo_df.join(self.data,how=&#39;inner&#39;) #inner join
            dpo_df = dpo_df.dropna(axis=0) #dropping nans
            dpo_df = dpo_df.iloc[:,1:]
            dpo_df_corr = dpo_df.corr() #corr matrix
            if(plot == True):
                dpo_plt =dpo_df.iloc[:,[0,5]]
                dpo_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return dpo_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),dpo_df,dpo_df.describe()
            else:
                return dpo_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),dpo_df,dpo_df.describe()
        
        elif(indicator == &#39;ADX&#39;):
            adx = ta.ADX(self.high, self.low, self.close, timeperiod=14)
            adx_df = pd.DataFrame(adx)
            adx_df = adx_df.rename(columns={0:&#39;ADX&#39;})
            adx_df = adx_df.join(self.data,how=&#39;inner&#39;)
            adx_df = adx_df.dropna(axis=0)
            adx_df_corr = adx_df.corr()
            if(plot==True):
                adx_plt = adx_df.iloc[:,[0,2,3,5]]
                adx_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
                return adx_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),adx_df,adx_df.describe()
            else:
                return adx_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),adx_df,adx_df.describe()
        
        else:
            raise ValueError(&#34;Invalid Indicator Symbol&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Frameworks.TechnicalAnalyzer.Tech_IndicatorEvaluator.getIndicator"><code class="name flex">
<span>def <span class="ident">getIndicator</span></span>(<span>self, indicator, plot=False, xmin=None, xmax=None, ymin=None, ymax=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIndicator(self,indicator, plot=False, xmin=None, xmax=None, ymin=None, ymax=None):
    
    if(xmin != None):
        if(type(xmin)!=str):
            raise ValueError(&#34;X parameters must be of type -&gt; str&#34;)
    
    if(xmax != None):
        if(type(xmax)!=str):
            raise ValueError(&#34;X parameters must be of type -&gt; str&#34;)
            
    if(ymin != None):
        if(not isinstance(ymin, (int, float))):
            raise ValueError(&#34;Y parameters must be of type -&gt; Int or Float&#34;)
                             
    if(ymax != None):
        if(not isinstance(ymax, (int,float))):
            raise ValueError(&#34;Y parameters must be of type -&gt; Int or Float&#34;)
            
            
        &#34;&#34;&#34;
        Bollinger BandsÂ® are a technical analysis tool developed by John Bollinger.
        There are three lines that compose Bollinger Bands: A simple moving average (middle band) and an upper and lower band.
        The upper and lower bands are typically 2 standard deviations +/- from a 20-day simple moving average, but can be modified
    
        Many traders believe the closer the prices move to the upper band, the more overbought the market,
        and the closer the prices move to the lower band, the more oversold the market.
    
        &#34;&#34;&#34;
    if(indicator == &#39;BBANDS&#39;):
        BB = ta.BBANDS(self.close)  #talib function)
        BB_df = pd.DataFrame(list(BB)).transpose() #converting to Dataframe
        BB_df = BB_df.rename(columns={0:&#39;Upperband&#39;,1:&#34;Middleband&#34;,2:&#34;Lowerband&#34;}) #renaming columns
        BB_df = BB_df.join(self.data , how=&#39;inner&#39;) #inner join with the OHLCV dataframe(on common timestamps)
        BB_df = BB_df.dropna(axis=0) #drop NaNs
        BB_df_corr=BB_df.corr(method=&#39;pearson&#39;) #corr matrix
        
        if (plot == True):
            BB_plot = BB_df.loc[:,[&#39;Upperband&#39;,&#39;Middleband&#39;,&#39;Lowerband&#39;,&#39;Close&#39;]] #select dependent columns ---&gt; can be changed here 
            BB_plot.plot(ylim=(ymin,ymax),xlim=(xmin,xmax)) #plot figure
            return BB_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),BB_df,BB_df.describe() 
        else:
            return BB_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),BB_df,BB_df.describe()
        
        &#34;&#34;&#34;
        The Arron indicator is composed of two lines. 
        An up line which measures the number of periods since a High, 
        and a down line which measures the number of periods since a Low.
        
        When the Aroon Up is above the Aroon Down, it indicates bullish price behavior.
        When the Aroon Down is above the Aroon Up, it signals bearish price behavior.
        
        For example, when Aroon Up crosses above Aroon Down it may mean a new uptrend is starting.
        &#34;&#34;&#34;
    elif(indicator == &#39;AROON&#39;):
        aroondf = ta.AROON(self.high,self.low,timeperiod=20)
        aroondf= pd.DataFrame(list(aroondf)).transpose()
        aroondf = aroondf.rename(columns={0:&#34;AroonDown&#34;,1:&#34;AroonUp&#34;})
        aroondf = aroondf.join(self.data,how=&#39;inner&#39;)
        aroondf = aroondf.dropna(axis=0)
        aroon_corr = aroondf.corr()
        if(plot == True):
            aroon_plt= aroondf.iloc[:,[0,1,3,4]] #Selected Dependent columns ---&gt; can be changed here
            aroon_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return aroon_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),aroondf,aroondf.describe()
        else:
            return aroon_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),aroondf,aroondf.describe()
        
    elif(indicator == &#39;CCI&#39;):
        cci = list(ta.CCI(self.high, self.low, self.close)) #Talib function
        cci_df = self.data.copy() #creating a copy of OHLCV DataFramee
        cci_df[&#39;Real&#39;] = pd.Series(cci).values  #converting to a series and appending to the  prev Dataframe
        cci_df = cci_df.dropna(axis=0)
        cci_corr= cci_df.corr()
        #self.data=self.data.iloc[:,:6]  
        if(plot == True):
            cci_plt = cci_df.iloc[:,[1,2,6]]
            cci_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return cci_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cci_df,cci_df.describe()
        else:
            return cci_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cci_df,cci_df.describe()
    
    elif(indicator == &#39;ATR&#39;):
        atr = ta.ATR(self.high,self.low,self.close,timeperiod=14)
        atrdf= pd.DataFrame(atr)
        atrdf = atrdf.rename(columns={0:&#34;ATR_real&#34;})
        atrdf = atrdf.join(self.data,how=&#39;inner&#39;)
        atrdf = atrdf.dropna(axis=0)
        atr_corr = atrdf.corr()
        if(plot==True):
            atr_plt = atrdf.iloc[:,[0,2,3,5]]
            atr_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return atr_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),atrdf,atrdf.describe()
        else:
            return atr_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),atrdf,atrdf.describe()
    
    elif(indicator == &#39;CHAIKINAD&#39;):
        chaikinad = ta.AD(self.high, self.low, self.close, self.volume)
        chaikinad_df = pd.DataFrame(chaikinad)
        chaikinad_df = chaikinad_df.rename(columns={0:&#34;ChaikinAD&#34;})
        chaikinad_df = chaikinad_df.join(self.data,how=&#39;inner&#39;)
        chaikinad_df = chaikinad_df.dropna(axis=0)
        chaikinad_corr = chaikinad_df.corr()
        if(plot==True):
            chaikinad_plt = chaikinad_df.iloc[:,[0,2,3,5]]
            chaikinad_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return chaikinad_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikinad_df,chaikinad_df.describe()
        else:
            return chaikinad_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikinad_df,chaikinad_df.describe()
        
    elif(indicator == &#39;CHAIKINVOLATILITY&#39;):
        chaikin_os = ta.ADOSC(self.high,self.low,self.close,self.volume)
        chaikin_os_df = pd.DataFrame(chaikin_os)
        chaikin_os_df = chaikin_os_df.rename(columns={0:&#34;ChaikinOSC&#34;})
        chaikin_os_df = chaikin_os_df.join(self.data,how=&#39;inner&#39;)
        chaikin_os_df = chaikin_os_df.dropna(axis=0)
        chaikin_os_corr= chaikin_os_df.corr()
        if(plot==True):
            chaikin_os_plt = chaikin_os_df.iloc[:,[0,2,3,5]]
            chaikin_os_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return chaikin_os_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikin_os_df,chaikin_os_df.describe()
        else:
            return chaikin_os_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),chaikin_os_df,chaikin_os_df.describe()
        
    elif(indicator == &#39;CMO&#39;):
        cmo = ta.CMO(self.close, timeperiod=14)
        cmo_df = pd.DataFrame(cmo)
        cmo_df = cmo_df.rename(columns={0:&#34;CMO&#34;})
        cmo_df = cmo_df.join(self.data,how=&#39;inner&#39;)
        cmo_df = cmo_df.dropna(axis=0)
        cmo_corr = cmo_df.corr()
        if(plot==True):
            cmo_plt = cmo_df.iloc[:,[0,5]]
            cmo_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return cmo_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmo_df,cmo_df.describe()
        else:
            return cmo_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmo_df,cmo_df.describe()
    
    elif(indicator == &#39;MACD&#39;):
        macd = ta.MACD(self.close, fastperiod=6, slowperiod=13, signalperiod=5)
        macd_df = pd.DataFrame(macd).transpose()
        macd_df = macd_df.rename(columns={0:&#34;macd&#34;,1:&#34;MACDSignal&#34;,2:&#34;MACDHist&#34;})
        macd_df = macd_df.join(self.data,how=&#39;inner&#39;)
        macd_df = macd_df.dropna(axis=0)
        macd_df_corr = macd_df.corr()
        if(plot == True):
            macd_plt = macd_df.iloc[:,[0,1,7]]
            macd_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return macd_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),macd_df,macd_df.describe()
        else:
            return macd_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),macd_df,macd_df.describe()
    
    elif(indicator == &#39;ROC&#39;):
        roc = ta.ROC(self.close, timeperiod=14)
        roc_df = pd.DataFrame(roc)
        roc_df = roc_df.rename(columns={0:&#34;ROC_value&#34;})
        roc_df = roc_df.join(self.data,how=&#39;inner&#39;)
        roc_df_corr= roc_df.corr()
        if(plot == True):
            roc_df_plt = roc_df.iloc[:,[0,5]]
            roc_df_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return roc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),roc_df,roc_df.describe()
        else:
            return roc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),roc_df,roc_df.describe()
    
    elif(indicator == &#39;MOMENTUM&#39;):
        mom = ta.MOM(self.close , timeperiod=14)
        mom_df = pd.DataFrame(mom)
        mom_df = mom_df.rename(columns={0:&#39;Momentum&#39;})
        mom_df = mom_df.join(self.data,how=&#39;inner&#39;)
        mom_df_corr = mom_df.corr()
        if(plot==True):
            mom_plt=mom_df.iloc[:,[0,5]]
            mom_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return mom_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mom_df,mom_df.describe()
        else:
            return mom_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mom_df,mom_df.describe()
    
    elif(indicator == &#39;RSI&#39;):
        rsi = ta.RSI(self.close, timeperiod=14)
        rsi_df = pd.DataFrame(rsi)
        rsi_df = rsi_df.rename(columns={0:&#34;RSI&#34;})
        rsi_df = rsi_df.join(self.data,how=&#34;inner&#34;)
        rsi_df = rsi_df.dropna(axis=0)
        rsi_df_corr = rsi_df.corr()
        if(plot == True):
            rsi_plt = rsi_df.iloc[:,[0,5]]
            rsi_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return rsi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),rsi_df,rsi_df.describe()
        else:
            return rsi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),rsi_df,rsi_df.describe()
        
    elif(indicator == &#39;MFI&#39;):
        mfi = ta.MFI(self.high, self.low, self.close, self.volume, timeperiod=14)
        mfi_df = pd.DataFrame(mfi)
        mfi_df = mfi_df.rename(columns={0:&#34;MFI&#34;})
        mfi_df = mfi_df.join(self.data,how=&#39;inner&#39;)
        mfi_df = mfi_df.dropna(axis=0)
        mfi_df_corr= mfi_df.corr()
        if(plot==True):
            mfi_plt = mfi_df.iloc[:,[0,2,3,5,6]]
            mfi_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return mfi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mfi_df,mfi_df.describe()
        else:
            return mfi_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),mfi_df,mfi_df.describe()
    
    elif(indicator == &#39;OBV&#39;):
        obv = ta.OBV(self.close, self.volume)
        obv_df = pd.DataFrame(obv)
        obv_df = obv_df.rename(columns={0:&#39;OBV&#39;})
        obv_df = obv_df.join(self.data,how=&#39;inner&#39;)
        obv_df_corr = obv_df.corr()
        if(plot == True):
            obv_plt = obv_df.iloc[:,[0,5]]
            obv_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return obv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),obv_df,obv_df.describe()
        else:
            return obv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),obv_df,obv_df.describe()
        
    elif(indicator == &#39;SAR&#39;):
        sar = ta.SAR(self.high, self.low, acceleration=1, maximum=1)
        sar_df = pd.DataFrame(sar)
        sar_df = sar_df.rename(columns={0:&#39;SAR&#39;})
        sar_df = sar_df.join(self.data,how=&#39;inner&#39;)
        sar_df = sar_df.dropna(axis=0)
        sar_df_corr = sar_df.corr()
        if(plot == True):
            sar_plt = sar_df.iloc[:,[0,2,3]]
            sar_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return sar_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),sar_df,sar_df.describe()
        else:
            return sar_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),sar_df,sar_df.describe()
        
    elif(indicator == &#39;STOCHASTIC&#39;):
        stoch = ta.STOCH(self.high, self.low, self.close, fastk_period=14, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0)
        stoch_df = pd.DataFrame(list(stoch)).transpose()
        stoch_df = stoch_df.rename(columns={0:&#34;SlowK&#34;,1:&#34;SlowD&#34;})
        stoch_df = stoch_df.join(self.data,how=&#39;inner&#39;)
        stoch_df = stoch_df.dropna(axis=0)
        stoch_df_corr = stoch_df.corr()
        if(plot == True):
            stoch_plt = stoch_df.iloc[:,[0,1,3,4,6]]
            stoch_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return stoch_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),stoch_df,stoch_df.describe()
        else:
            return stoch_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),stoch_df,stoch_df.describe()
        
    elif(indicator == &#39;TRIX&#39;):
        trix = ta.TRIX(self.close, timeperiod=20)
        trix_df = pd.DataFrame(trix)
        trix_df = trix_df.rename(columns={0:&#39;Trix&#39;})
        trix_df= trix_df.join(self.data, how=&#39;inner&#39;)
        trix_df = trix_df.dropna(axis=0)
        trix_df_corr = trix_df.corr()
        if(plot==True):
            trix_plt = trix_df.iloc[:,[0,5]]
            trix_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return trix_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),trix_df,trix_df.describe()
        else:
            return trix_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),trix_df,trix_df.describe()
        
    elif(indicator == &#39;ultimateOscillator&#39;):
        ultiosc = ta.ULTOSC(self.high, self.low, self.close, timeperiod1=7, timeperiod2=14, timeperiod3=28)
        ultiosc_df = pd.DataFrame(ultiosc)
        ultiosc_df = ultiosc_df.rename(columns={0:&#34;ULTI_OSC&#34;})
        ultiosc_df = ultiosc_df.join(self.data,how=&#39;inner&#39;)
        ultiosc_df = ultiosc_df.dropna(axis=0)
        ultiosc_df_corr = ultiosc_df.corr()
        if(plot == True):
            ultiosc_plt = ultiosc_df.iloc[:,[0,2,3,5]]
            ultiosc_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return ultiosc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),ultiosc_df,ultiosc_df.describe()
        else:
            return ultiosc_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),ultiosc_df,ultiosc_df.describe()
    
    elif(indicator == &#39;CLV&#39;):
        clvlist = [] #creating an empty list 
        for i in range(0, self.data.shape[0]):
            #CLV = ((Close - Low) - (High - Close))/(High - Low)
            clv = ((self.data.iloc[i,3] - self.data.iloc[i,2]) - 
                   (self.data.iloc[i,1] - self.data.iloc[i,3]))/(self.data.iloc[i,1] - self.data.iloc[i,2])
            clvlist.append(clv) #appending values to list
        clv_df = pd.DataFrame() #creating an empty Dataframe
        clv_df = self.data.copy() #creating a copy of OHLCV Dataframe
        clv_df[&#39;CLV&#39;] = clvlist #appending a column of values from clvlist
        clv_df_corr = clv_df.corr() #corr matrix
        
        if(plot==True):
            clv_plt = clv_df.iloc[:,[1,2,4,6]]
            clv_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return clv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),clv_df,clv_df.describe()
        else:
            return clv_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),clv_df,clv_df.describe()
    
    elif(indicator == &#39;CMF&#39;):
        temp =[] #empty list
        for i in range(0,self.data.shape[0]):
            
            #MoneyFlowMultiplier = ((Close - Low) - (High - Close))/(High - Low)
            mfm = ((self.data.iloc[i,3] - self.data.iloc[i,2]) - (self.data.iloc[i,1] - self.data.iloc[i,3]))/(self.data.iloc[i,1] - self.data.iloc[i,2])
            #MoneyFlowMultipler x Volume of that period = MoneyFlow Volume
            cmf = mfm*self.data.iloc[i,4]
            temp.append(cmf)
            
        cmf_df = pd.DataFrame() #Create an empty dataframe
        cmf_df[&#39;MFVolume&#39;] = temp #append list in Dataframe
        cmf_df[&#39;Volume&#39;] = list(self.volume) #Add Volume data in dataframe
        cmf_df = cmf_df.rolling(20).sum() #Rolling sum for timeperiod = 20 ----&gt; can be changed
        cmf_df[&#39;Ratio&#39;] = cmf_df[&#39;MFVolume&#39;]/cmf_df[&#39;Volume&#39;] #Taking raio
        cmflist = list(cmf_df.iloc[:,2]) #creating a list of the ratios obtained
        cmf_df = pd.DataFrame() #appending it to the empty DataFrame
        cmf_df = self.data.copy()
        cmf_df[&#39;CMF&#39;] = cmflist
        cmf_df = cmf_df.dropna(axis=0) #Dropping NaN
        cmf_df_corr = cmf_df.corr() #Corr Matrix
        if(plot==True):
            cmf_plt = cmf_df.iloc[:,[1,2,4,5,6]]
            cmf_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return cmf_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmf_df,cmf_df.describe()
        else:
            return cmf_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),cmf_df,cmf_df.describe()
        
    elif(indicator == &#39;Donchain&#39;):
        temp =[]
        highest = pd.DataFrame(self.data.iloc[:,1].rolling(20).max()) #Highest 20 day high
        lowest = pd.DataFrame(self.data.iloc[:,2].rolling(20).min()) #Lowest 20 day Low
        combined = highest.join(lowest,how=&#39;inner&#39;) #comibining on inner join
        for i in range(0,combined.shape[0]):
            if(math.isnan(combined.iloc[i,1]) == True or math.isnan(combined.iloc[i,0] == True)):
                temp.append(None)
            else:
                temp.append((combined.iloc[i,0] + combined.iloc[i,1])/2) #The middle = (Highest+Lowest)/2
        combined[&#39;Mid&#39;] = temp
        combined = combined.rename(columns={&#39;High&#39;:&#34;Upper&#34;,&#34;Low&#34;:&#39;Lower&#39;,&#34;Mid&#34;:&#34;Middle&#34;}) #Renaming Columns
        donchain_df = combined.join(self.data, how=&#39;inner&#39;) #joining with OHLCV data
        donchain_df.dropna(axis=0) #Dropping NaNs
        donchain_df_corr = donchain_df.corr()
        if(plot == True):
            donchain_plt = donchain_df.iloc[:,[0,1,2,4,5,7]]
            donchain_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return donchain_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),donchain_df,donchain_df.describe()
        else:
            return donchain_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),donchain_df,donchain_df.describe()
        
    elif(indicator == &#39;DPO&#39;):
        time = 20
        dpo = ta.SMA(self.close, timeperiod=time) #Calculate Simple Moving Average
        dpo_df = pd.DataFrame(dpo)
        dpo_df[&#39;DPO&#39;] = np.nan #Create a column filled with NaNs
        
        #Start from i = timeperiod 
        for i in range(time-1,dpo_df.shape[0]):
            #(Price of (N/2 + 1) periods ago) - (N Period SMA) = DPO
            dpo_df.iloc[i,1] = self.data.iloc[(i//2+1),3] - dpo_df.iloc[i,0]
            
        dpo_df = dpo_df.join(self.data,how=&#39;inner&#39;) #inner join
        dpo_df = dpo_df.dropna(axis=0) #dropping nans
        dpo_df = dpo_df.iloc[:,1:]
        dpo_df_corr = dpo_df.corr() #corr matrix
        if(plot == True):
            dpo_plt =dpo_df.iloc[:,[0,5]]
            dpo_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return dpo_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),dpo_df,dpo_df.describe()
        else:
            return dpo_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),dpo_df,dpo_df.describe()
    
    elif(indicator == &#39;ADX&#39;):
        adx = ta.ADX(self.high, self.low, self.close, timeperiod=14)
        adx_df = pd.DataFrame(adx)
        adx_df = adx_df.rename(columns={0:&#39;ADX&#39;})
        adx_df = adx_df.join(self.data,how=&#39;inner&#39;)
        adx_df = adx_df.dropna(axis=0)
        adx_df_corr = adx_df.corr()
        if(plot==True):
            adx_plt = adx_df.iloc[:,[0,2,3,5]]
            adx_plt.plot(ylim=(ymin,ymax),xlim=(xmin,xmax))
            return adx_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),adx_df,adx_df.describe()
        else:
            return adx_df_corr.style.background_gradient(cmap=&#39;coolwarm&#39;),adx_df,adx_df.describe()
    
    else:
        raise ValueError(&#34;Invalid Indicator Symbol&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Frameworks" href="index.html">Frameworks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Frameworks.TechnicalAnalyzer.Tech_IndicatorEvaluator" href="#Frameworks.TechnicalAnalyzer.Tech_IndicatorEvaluator">Tech_IndicatorEvaluator</a></code></h4>
<ul class="">
<li><code><a title="Frameworks.TechnicalAnalyzer.Tech_IndicatorEvaluator.getIndicator" href="#Frameworks.TechnicalAnalyzer.Tech_IndicatorEvaluator.getIndicator">getIndicator</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>